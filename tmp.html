<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Tailin Song 宋泰霖 (https://songtailin.github.io)</title>
<style>
ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #333;
}

li {
    float: left;
}

li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none;
}

li a:hover:not(.active) {
    background-color: #111;
}

.active {
    background-color: #4CAF50;
}
</style>
</head>

<body>

<p>function [ y,n] = sigadd( x1,n1,x2,n2 )
%UNTITLED6 此处显示有关此函数的摘要
%   此处显示详细说明
n=min(min(n1),min(n2)):max(max(n1),max(n2));%这里求的是加法结果的横坐标范围
y1=zeros(1,length(n));
y2=y1;%先让两个序列都为0
y1(find((n>=min(n1))&(n<=max(n1)==1)))=x1;%给y1横坐标位置为n1的地方都赋x1的值
y2(find((n>=min(n2))&(n<=max(n2)==1)))=x2;%给y2横坐标位置为n2的地方都赋x2的值
y=y1+y2;%序列相加
end</p>

<p>function [y,n]=sigfold(x,m)
y=fliplr(x);
n=-fliplr(m);
end</p>

<p>function [y,n]=sigmult(x1,n1,x2,n2)
n=min(min(n1),min(n2)):max(max(n1),max(n2));
y1=zeros(1,length(n));
y2=y1;
y1(find((n>=min(n1))&(n<=max(n1)==1)))=x1;%给y1横坐标位置为n1的地方都赋x1的值
y2(find((n>=min(n2))&(n<=max(n2)==1)))=x2;%给y2横坐标位置为n2的地方都赋x2的值
y=y1.*y2;</p>

<p>function [x,n]=stepseq(n0,n1,n2,dt)
n=[n1:dt:n2];
x=[(n-n0)>=0];
end
%单位阶跃</p>

<p>clc,close all;
figure
n=[-2:10];x=[1:7,6:-1:1];%序列x(n)
[x1,xn1]=sigfold(x,n);%第一部分-翻转
[x2,xn2]=sigmult(x,n,x,n+3);%第二部分-相乘
[y,ny]=sigadd(0.2*x1,xn1+5,0.3*x2,xn2)%序列相加
figure
stem(ny,y)</p>

<p>clc,close all;
n1=-10:10;
x1=0.5*n1.*(stepseq(0,-10,10)-stepseq(6,-10,10));
n2=-10:10;
x2=2*sin(pi*n2/2).*(stepseq(-3,-10,10)-stepseq(4,-10,10));
[y,n]=conv_h(x1,n1,x2,n2);
figure
stem(n1,x1);
axis([-10,10,-5,5]);
figure
stem(n2,x2);
axis([-10,10,-5,5]);
figure
stem(n,y);
axis([-10,10,-5,5]);
function [y,n]=conv_h(x1,n1,x2,n2)
n=(min(n1)+min(n2)):(max(n1)+max(n2));
conv_h=zeros(length(n1),length(n));
for i=1:length(n1)
    for j=i:i+length(n2)-1
        conv_h(i,j)=x1(i)*x2(j-i+1);
    end
end
y=sum(conv_h,1);
end</p>

<p>clc,close all;
T=2;dt=0.00001;
t=-2:dt:2;
x=0;
%生成矩形波
for m=-1:1  %周期延拓
    % x = x+u(t+m*T)-u(t+m*T-1);
    % x = x+(t>=(t+m*T-1)&t<(t+m*T));
    % x = x+stepseq(t+m*T)-steqseq(t+m*T-1);
    [x1,n1]=stepseq(0+m*T,-2,2,dt);
    [x2,n2]=stepseq(1+m*T,-2,2,dt); 
    x= x+ x1-x2;  
end
mask=[zeros(1,100000),ones(1,200000),zeros(1,100001)];
t=mask.*t;
x=mask.*x;
%plot(t,x);
w0=2*pi/T;
N=10; %谐波次数
L=2*N+1;
for k = -N:N  %计算系数
    ak(N+1-k) = (1/T)*x*exp(-j*k*w0*t')*dt;
end
phi=angle(ak);  %相位
extent=abs(ak);
X=0;
for k=-N:N
    X=X+ak(k+N+1)*exp(j*k*w0*t);
end

N=10;k1=-N:N;
[X1,phi1,extent1]=calculate(N,T,x,t,dt);
figure
subplot(2,2,1.5);
plot(t,X1);
title("N=10")
figure
stem(k1,extent1);
title("N=10")

N=20;k2=-N:N;
[X2,phi2,extent2]=calculate(N,T,x,t,dt);
figure
subplot(2,2,1.5);
plot(t,X2);
title("N=20")
figure
stem(k2,extent2);
title("N=20")

N=30;k3=-N:N;
[X3,phi3,extent3]=calculate(N,T,x,t,dt);
figure
subplot(2,2,1.5);
plot(t,X3);
title("N=30")
figure
stem(k3,extent3);
title("N=30")

N=40;k4=-N:N;
[X4,phi4,extent4]=calculate(N,T,x,t,dt);
figure
subplot(2,2,1.5);
plot(t,X4);
title("N=40")
figure
stem(k4,extent4);
title("N=40")

function [X,phi,extent] = calculate(N,T,x,t,dt)
    w0=2*pi/T;
    for k=-N:N %计算系数
        ak(N+1+k)=(1/T)*x*exp(-j*k*w0*t')*dt;
    end
    phi=angle(ak);
    extent=abs(ak);
    X=0;
    for k=-N:N
        X=X+ak(k+N+1)*exp(j*k*w0*t);
    end
end</p>

<p>clc,close all;

dt=0.001;t=-10:dt:10;
dw=0.1;w=-10*pi:dw:10*pi;
x=cos(pi/2*t).*(t>=-1&t<1)+zeros(1,length(t));
figure
plot(t,x)
axis([-4,4,-1,2])
title("原信号")

%公式法计算频谱
X1=x*exp(-j*w.*t')*dt;
figure
stem(w/(2*pi),abs(X1));
axis([0,4,-inf,inf])
title("公式法计算幅度谱")

%利用fft函数计算频谱
N=2048;fs=N/(max(t)-min(t));
X2=fft(x);
P2=abs(X2/N);%为了得到真实幅值，需要将变换后的结果/N
P1=P2(1:N/2+1);%前一半与后一半信息重复
P1(1:end-1)=2*P1(1:end-1);%除零频外的成分幅值要*2
f=fs*(0:N/2)/N;
figure
stem(f,P1)
axis([0,4,-inf,inf])
title("fft法计算幅度谱")</p>

<p>clc,clear all;
[x,y]=fftnyf(128,16);
figure
subplot(221)
plot(x,y);title('N=128,L=16');
axis([-300,300,0,1.2]);
[x2,y2]=fftnyf(128,32);
figure
subplot(221)
plot(x2,y2);title('N=128,L=32');
axis([-300,300,0,1.2]);
[x3,y3]=fftnyf(128,64);
figure
subplot(221)
plot(x3,y3);title('N=128,L=64');
axis([-300,300,0,1.2]);
[x4,y4]=fftnyf(128,128);
figure
subplot(221)
plot(x4,y4);title('N=128,L=128');
axis([-300,300,0,1.2]);
[x5,y5]=fftnyf(128,256);
figure
subplot(221)
plot(x5,y5);title('N=128,L=256');
axis([-300,300,0,1.2]);
[x6,y6]=fftnyf(128,512);
figure
subplot(221)
plot(x6,y6);title('N=128,L=512');
axis([-300,300,0,1.2]);

function [x,y]=fftnyf(N,L)
    fs=600;f1=100;f2=120;
    t=(0:N-1)*1/fs;
    x=cos(2*pi*f1*t)+cos(2*pi*f2*t);
    F=fft(x,L);
    x=(-L/2:L/2-1)*fs/L;
    y=fftshift(abs(F)*2/min(N,L));
end</p>

<p>clc,clear all;

[x,y]=fftnyf(64,64);
figure
plot(x,y);title('N=64,L=64');
axis([-0.5,0.5,0,1]);
[x2,y2]=fftnyf(64,128);
figure
plot(x2,y2);title('N=64,L=128');
axis([-0.5,0.5,0,1]);
function [x,y]=fftnyf(N,L)
    t=(0:63);
    x=cos(2*pi*t/15)+0.75*cos(2.3*pi*t/15);
    F=fft(x,L);
    x=(-L/2:L/2-1)/L;
    y=fftshift(abs(F)*2/min(N,L));   %补零
    %y=abs(F/length(x));             %不补零
end</p>

<p>clc,clear all

%原始信号
fs=100000;
ts=1/fs;t0=0.01;
t=-t0:ts:t0;
x=exp(-1000*abs(t));
figure
subplot(211)
plot(t,x),title('原始信号')
dw=pi;
w=-10000*pi:dw:10000*pi;
xw=x*exp(-1i*w.*t')*ts;%绘制原始信号频谱
subplot(212)
plot(w/2/pi,abs(xw));
xlabel('频率/（单位：hz）'),ylabel('X(w)*1000'),title('原始信号频谱')
wc=2000*2*pi;

%利用傅里叶级数重建-临界
fs=4000;T=1/fs;
[y1,yw1,t1,w1,yr1]=caiyang(fs);
figure
subplot(211)
ak=fix(5000/fs)*2+1;
plot(w1/2/pi,abs(yw1));
xlabel('频率/（单位：hz）'),ylabel('X(w)*1000'),title('临界采样信号频谱')
subplot(212)
plot(t1,yr1/ak,'linewidth',2),title('重建信号');%hold on;

%利用采样信号重建-临界
Ts = T;
n = -0.01/T:0.01/T;
nTs = n*Ts;%采样点
x = exp(-1000*abs(nTs));
figure
%subplot(3,1,3);
plot(t1,yr1/ak,'linewidth',2);
hold on;
stem(n*Ts,x)
yr1=chongjian(wc,T,t1,y1);
plot(t1,yr1,'o');hold on;
plot(t1,y1,'g*');
legend('利用傅里叶级数重建','采样后的原始信号','利用采样信号重建','重建后的原始信号'),title('临界采样')

%利用傅里叶级数重建-过
fs=6000;T=1/fs;
[y1,yw1,t1,w1,yr1]=caiyang(fs);
figure
subplot(211)
ak=fix(5000/fs)*2+1;
plot(w1/2/pi,abs(yw1));
xlabel('频率/（单位：hz）'),ylabel('X(w)*1000'),title('过采样信号频谱')
subplot(212)
plot(t1,yr1/ak,'linewidth',2),title('重建信号');%hold on;

%利用采样信号重建-过
Ts = T;
n = -0.01/T:0.01/T;
nTs = n*Ts;%采样点
x = exp(-1000*abs(nTs));
figure
%subplot(3,1,3);
plot(t1,yr1/ak,'linewidth',2);
hold on;
stem(n*Ts,x)
yr1=chongjian(wc,T,t1,y1);
plot(t1,yr1/ak,'o');hold on;
plot(t1,y1,'g*');
legend('利用傅里叶级数重建','采样后的原始信号','利用采样信号重建','重建后的原始信号'),title('过采样')

%利用傅里叶级数重建-欠
fs=2000;T=1/fs;
[y1,yw1,t1,w1,yr1]=caiyang(fs);
figure
subplot(211)
ak=fix(5000/fs)*2+1;
plot(w1/2/pi,abs(yw1));
xlabel('频率/（单位：hz）'),ylabel('X(w)*1000'),title('欠采样信号频谱')
subplot(212)
plot(t1,yr1/ak,'linewidth',2),title('重建信号');%hold on;


%利用采样信号重建-欠
Ts = T;
n = -0.01/T:0.01/T;
nTs = n*Ts;%采样点
x = exp(-1000*abs(nTs));
figure
%subplot(3,1,3);
plot(t1,yr1/ak,'linewidth',2);
hold on;
stem(n*Ts,x)
yr1=chongjian(wc,T,t1,y1);
plot(t1,yr1,'o');hold on;
plot(t1,y1,'g*');
legend('利用傅里叶级数重建','采样后的原始信号','利用采样信号重建','重建后的原始信号'),title('欠采样')

function [y,yw,t,w,yr]=caiyang(fs)
    ts=1/fs;
    t=-0.01:ts:0.01;
    y=exp(-1000*abs(t));
    dw=pi;
    w=-10000*pi:dw:10000*pi;
    yw=y*exp(-1i*w.*t')*ts;
    yr=1/2/pi*yw*exp(1i*w'*t)*dw;
end

function yr=chongjian(wc,T,t,x)
    n=length(t);l=-(n-1)/2:(n-1)/2;
    yr=0;
    for i=1:n
        yr=yr+x(i)*wc*T/pi*sinc((wc*(t-l(i)*T))/pi);
    end
end</p>

<p>clc,clear all;
N=25;
N1=50;
f1=100;f2=150;fs=600;
t=(1:100)*1/fs;
x=cos(2*pi*f1*t)+0.15*cos(2*pi*f2*t);
%矩形窗
win=[zeros(1,floor((length(t)-N)/2)),rectwin(N)',zeros(1,ceil((length(t)-N)/2))];
win1=[zeros(1,floor((length(t)-N1)/2)),rectwin(N1)',zeros(1,ceil((length(t)-N1)/2))];
%海明窗hamming(N)
%win=hamming(N);
%win1=hamming(N1);
figure
subplot(151);
stem(t,x),title('原始信号'),axis([0,t(end),-1.5,1.5])
subplot(252)
stem(win),title('矩形窗，N=25'),axis([0,100,0,1.2])
subplot(257)
stem(win1),title('矩形窗，N=50'),axis([0,100,0,1.2])

X=x.*win;
X1=x.*win1;
X(X==0) = [];
X1(X1==0) = [];
subplot(253)
stem(t(1:N),X(1:N)),title('加窗信号')
subplot(258)
stem(t(1:N1),X1(1:N1)),title('加窗信号')

L=length(win);
L1=length(win1);
[f,y]=fftnyf(L,L,win,fs);
subplot(254)
plot(f,y),title('窗函数的傅里叶变换')
[f1,y1]=fftnyf(L1,L1,win1,fs);
subplot(259)
plot(f1,y1),title('窗函数的傅里叶变换')

[f,y]=fftnyf(N,N,X,fs);
subplot(255)
plot(f,y),title('加窗后的傅里叶变换')
[f1,y1]=fftnyf(N1,N1,X1,fs);
subplot(2,5,10)
plot(f1,y1),title('加窗后的傅里叶变换')

function [f,y]=fftnyf(L,N,X,fs)
    F=fft(X,L);
    f=(-L/2:L/2-1)*fs/L;
    y=fftshift(abs(F)*2/min(N,L));
end</p>

<p>clc,clear all;
N=25;
N1=50;
f1=100;f2=150;fs=600;
t=(1:100)*1/fs;
x=cos(2*pi*f1*t)+0.15*cos(2*pi*f2*t);
%海明窗
win=[zeros(1,floor((length(t)-N)/2)),hamming(N)',zeros(1,ceil((length(t)-N)/2))];
win1=[zeros(1,floor((length(t)-N1)/2)),hamming(N1)',zeros(1,ceil((length(t)-N1)/2))];
figure
subplot(151);
stem(t,x),title('原始信号'),axis([0,t(end),-1.5,1.5])
subplot(252)
stem(win),title('海明窗，N=25'),axis([0,100,0,1.2])
subplot(257)
stem(win1),title('海明窗，N=50'),axis([0,100,0,1.2])

X=x.*win;
X1=x.*win1;
X(X==0) = [];
X1(X1==0) = [];
subplot(253)
stem(t(1:N),X(1:N)),title('加窗信号')
subplot(258)
stem(t(1:N1),X1(1:N1)),title('加窗信号')

L=length(win);
L1=length(win1);
[f,y]=fftnyf(L,L,win,fs);
subplot(254)
plot(f,y),title('窗函数的傅里叶变换')
[f1,y1]=fftnyf(L1,L1,win1,fs);
subplot(259)
plot(f1,y1),title('窗函数的傅里叶变换')

[f,y]=fftnyf(N,N,X,fs);
subplot(255)
plot(f,y),title('加窗后的傅里叶变换')
[f1,y1]=fftnyf(N1,N1,X1,fs);
subplot(2,5,10)
plot(f1,y1),title('加窗后的傅里叶变换')

function [f,y]=fftnyf(L,N,X,fs)
    F=fft(X,L);
    f=(-L/2:L/2-1)*fs/L;
    y=fftshift(abs(F)*2/min(N,L));
end</p>

<p>clear,close all;clc;
% 级联型
format long
num = [0.020083,0,-0.040167,0,0.020083];
den = [1,0,1.561,0,0.6413];
[z1,p1,k1] = tf2zp(num,den);
sos = zp2sos(z1,p1,k1)
% 并联型
[r2,p2,k2] = residuez(num,den)
R1 = [r2(1),r2(2)];
P1 = [p2(1),p2(2)];
[b1,a1] = residuez(R1,P1,0)
R2 = [r2(3),r2(4)];
P2 = [p2(3),p2(4)];
[b2,a2] = residuez(R2,P2,0)</p>

<p>clear,close all;clc;
fs=20000;
fp1=4500;fs1=3000;
fp2=6500;fs2=7500;
ws1=(fp1+fs1)/2/(fs/2);
ws2=(fp2+fs2)/2/(fs/2);
N=ceil(8*pi/((fs2-fp2)/fs*2*pi));
hann_win=hann(N);
hn=fir1(N-1,[ws1,ws2],hann_win);
figure
freqz(hn,1,fs,fs)
title('汉宁窗')

as=40;
b=(0.5842*(as-21)).^0.4+0.07886*(as-21);
N=ceil((as-8)/((fs2-fp2)/fs*2)+1);
win=kaiser(N,b);
ka=fir1(N-1,[ws1,ws2],win);
figure
freqz(ka,1,fs,fs)
title('Kaiser窗')

N=ceil(8*pi/((fs2-fp2)/fs*2*pi));
tri_win=bartlett(N);
tr=fir1(N-1,[ws1,ws2],tri_win);
figure
freqz(tr,1,fs,fs)
title('三角窗')

N=ceil(8*pi/((fs2-fp2)/fs*2*pi));
hamm_win=hamming(N);
hm=fir1(N-1,[ws1,ws2],hamm_win);
figure
freqz(hm,1,fs,fs)
title('海明窗')</p>

<p>clear,close all;clc;
%d=0;
%d=1;
d=2;
N=33*(d+1);
%采样点;
wc=3*pi/5;
% N1=fix(wc/(2*pi/N));  
% N2=N-2*N1;  
% A=[zeros(1,N1),ones(1,N2),zeros(1,N1)];
 N2=fix((pi-wc)*2/(2*pi/N));  %通带上采样点
 N1=(N-N2-2*d)/2;  %阻带上采样点
% A=[zeros(1,N1),ones(1,N2),zeros(1,N1)];
% A=[zeros(1,N1-1),0.7,ones(1,N2),0.7,zeros(1,N1-1)];
% A=[zeros(1,N1),0.7,ones(1,N2/2),-ones(1,N2/2),-0.7,zeros(1,N1)]; %偶数个点奇对称
 A=[zeros(1,N1),0.3,0.7,ones(1,N2),0.7,0.3,zeros(1,N1)];%奇数个点偶对称
theta=-pi*[0:N-1]*(N-1)/N;
H=A.*exp(j*theta);
h=real(ifft(H));
v=1:N;
figure
subplot(211);
plot((0:N-1)*2/N,A,'*'),xlabel('频率/pi'),ylabel('H(k)'),title('滤波器幅频响应')
subplot(212)
stem(v,h);ylabel('h(n)'),title('滤波器单位冲激响应')
figure
freqz(h,1)</p>

<p>clc,clear all;
% 参数定义
wp = 0.2;
ws = 0.4;
Ap = 0.5;
As = 20;
% 巴特沃斯型 
[N, wc] = buttord(wp,ws,Ap,As);
[b, a] = butter(N,wc);
figure(1);
freqz(b,a);
title(sprintf('N = %d 巴特沃斯型低通滤波器',N));
% 切比雪夫I型
[N, wc] = cheb1ord(wp, ws, Ap, As);
[b, a] = cheby1(N, Ap, wc);
figure(2)
freqz(b,a);
title(sprintf('N = %d 切比雪夫I型低通滤波器', N));
% 椭圆型
[N, wc] = ellipord(wp, ws, Ap, As);
[b, a] = ellip(N, Ap, As, wc);
figure(3);
freqz(b,a);
title(sprintf('N = %d 椭圆型低通滤波器', N));</p>

<p>clc,clear all;
fp=100;fs=200;f=500;
rp=2;rs=15;
T=1/f;
wp=2/T*tan(fp/f*pi);
ws=2/T*tan(fs/f*pi);
[N,wc]=buttord(wp,ws,rp,rs,'s');
[b,a]=butter(N,wc,'s');
[bt,at]=bilinear(b,a,f);
freqz(bt,at);</p>

<p>clc,close all;
w=[0:1:500]*pi/500;
H=exp(1i*w)./(exp(1i*w)-0.9*ones(1,501));
magH=abs(H);
angH=angle(H);
figure
subplot(211);plot(w/pi,magH);grid;
xlabel('w(单位:pi)');
ylabel('幅度|H|');
title('幅度响应');
subplot(212);
plot(w/pi,angH/pi);grid;
xlabel('w(单位; pi)');
ylabel('相位(rad/pi)');
title('相位响应');</p>

<p>T =1;
wp = 0.3*pi; ws = 0.5*pi; Ap = 2;As = 20;
%脉冲响应不变法
[N1,wn1] = buttord(wp,ws,Ap,As,'s');%模拟低通滤波器的阶数和截止频率
[B1,A1] = butter(N1,wn1,'s');%模拟低通滤波器
[num1,den1] = impinvar(B1,A1,1/T);%利用脉冲响应不变法转换为数字滤波器
[h1,w1] = freqz(num1,den1);
%双线性变换法
wp2 = (2/T)*tan(wp/2);
ws2 = (2/T)*tan(ws/2);%将数字指标转化为模拟指标
[N2,wn2] = buttord(wp2,ws2,Ap,As,'s')；%模拟低通滤波器的阶数和截止频率
[B2,A2] = butter(N2,wn2,'s'); %模拟低通滤波器
[num2,den2] = bilinear(B2,A2,1/T); %双线性变换法转换为数字滤波器
[h2,w2] = freqz(num2,den2);
plot(w1/pi,20*log10(abs(h1)),'-.',w2/pi,20*log10(abs(h2)),'-');
grid; xlabel('频率/Hz '); ylabel('幅度/dB')</p>

</body>
</html>